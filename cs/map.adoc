[[anchor-1]]

= Datový typ map!
:toc:
:numbered:
  

== Úvod

Struktura typu `map!` reprezentuje asociativní řadu (array) dvojic key/value. Poskytuje rychlý přístup pro čtení s interním použitím hashtable. Na rozdíl od datového typu `hash!` nepatří `map!` do skupiny `series!`, tudíž nezná koncept pozic (nevlastní interní iterátor). Koncepčně leží typ `map!` mezi datovými typy `hash!` a `object!`. Uživatelsky připomíná  slovník.

<<anchor-1,toc>>

== Literálová skladba
----
#(<key> <value>...)

<key>  : hashovaný klíč typu scalar!, all-word!, any-string!
<value> : hodnota typu any-type!
----

<<anchor-1,toc>>

== Creation syntax

----
make map! <spec>

<spec> : blok s páry `key/value` nebo celočíselná hodnota
----

Je-li _spec_ celé číslo, vytvoří se prázdný objekt typu `map!` s předurčeným počtem slotů (obvykle za účelem pozdějšího dynamického zaplnění mapy).

[NOTE]
==== 
* Tělo mapy (nebo blok specifikací) musí obsahovat *sudý* počet prvků, nemá-li být generována chyba.
* hodnoty nejsou *redukovány*, tudíž pro některé speciální hodnoty (např. logic!) je vyžadována _konstrukční_ skladba.
====
 

Příklady:

----
#(a: 1 b: 2)
== #(
    a: 1
    b: 2
)

make map! [a 1 'b 2 "c" 3]
== #(
    a: 1
    b: 2
    "c" 3
)
----


Je-li klíč typu *any-word*, je v mapě kvůli lepší přehlednosti konvertován na typ *set-word*. Nicméně, při dotazování na hodnotu klíčů, lze pro klíč z praktických důvodů (jednodušší zápis, zejména v cestách) použít jednoduchý tvar slova.
Podobně reflektor `keys-of` (popsaný v sekci Reflexe níže) vrací slova ve formátu `words` místo `set-words`, protože to zjednodušuje další zpracování (zejména shodování operací je snadnější se slovy než se set-slovy).

[NOTE]
====
* Stejně jako hash! a block! je map! implicitně [underline]#case-preserving# a [underline]#case-insensitive#.
* Je-li jako hodnota specifikováno `none`, klíč se nevytvoří (viz odstavec "Mazání klíčů").
* Při vytváření mapy jsou všechny klíče hluboce kopírovány.
* Hodnoty typu series! se při vytváření mapy implicitně nekopírují; volba je ponechána na uživateli (což optimalizuje zdroje v běžných způsobech použití).
====

Další způsob vytvoření nové mapy je kopírování existující:

----
mp: make map! 3
== #()
cmp: copy mp
== #()
----

<<anchor-1,toc>>

== Vyhledávání hodnot

S použitím cest:
----
<map>/<key>
get '<map>/<key>

<map> : slovo, odkazující na hodnotu typu map!
<key> : slovo, zastupující klíč
----

S použitím výběrové akce:
----
select <map> <key>

----

Všechny tyto přístupy při čtení jsou [underline]#case-insensitive#. Aby bylo vyhledávání [underline]#case-sensitive#, je zapotřebí ve vhodných případech použít upřesnění `/case`:

----
get/case '<map>/<key>
select/case <map> <key>
----

Pokus o vyhledání v mapě nedefinovaného klíče vrací hodnotu `none`.

Příklady:

----
m: #(Ab: 2 aB: 5 ab: 10)
m/ab
== 2
select m 'aB
== 2
get/case 'm/aB
== 5
select/case m 'ab
== 10
----

<<anchor-1,toc>>

== Změna klíčů a hodnot

S použitím cest:
----
<map>/<key>: <value>                ; změna pouze hodnoty
set '<map>/<key> <value>            ; dtto

<map>      : slovo, odkazující na hodnotu `map!`
<key>      : slovo pro výběr hodnoty v mapě
<value>    : jakákoli hodnota
----

S použitím modifikačních akcí:
----   
put <map> <key> <value>             ; vložení dvojice
----

Provedením hromadných změn:
----
extend <map> <spec>                 ; rozšíření o dvojici                 

<spec> : blok s dvojicemi name/value (jednou či vícero)
----

Všechny tyto čtecí přístupy jsou 'case-insensitive'. Case-sensitive variantu způsobí upřesnění `/case`:
----
set/case '<map>/<key> <value>
put/case <map> <key> <value>
extend/case <map> <spec>
----

Nativní funkce `extend` může současně přijmout mnoho klíčů, takže je pro hromadné změny vhodná

[NOTE] 
====
* zadání klíče, který dosud v mapě neexistuje, způsobí jeho vytvoření.
* přidání existujícího klíče změní jeho hodnotu, přičemž se implicitně provádí*case-insensitive* porovnávání.
====

Příklady:

----
m: #(Ab: 2 aB: 5 ab: 10)
m/ab: 3
m
== #(
    Ab: 3
    aB: 5
    ab: 10
)

put m 'aB "hello"
m
== #(
    Ab: "hello"
    aB: 5
    ab: 10
)

set/case 'm/aB 0
m
== #(
    Ab: "hello"
    aB: 0
    ab: 10
)
set/case 'm/ab 192.168.0.1
== #(
    Ab: "hello"
    aB: 0
    ab: 192.168.0.1
)

m: #(%cities.red 10)
extend m [%cities.red 99 %countries.red 7 %states.red 27]
m
== #(
    %cities.red 99
    %countries.red 7
    %states.red 27
)
----

<<anchor-1,toc>>

== Mazání klíčů

Dvojici key/value jednoduše z mapy vymažeme přiřazením hodnoty `none`  ke klíči - s použitím jednoho z možných způsobů:

----
m: #(a: 1 b 2 "c" 3 d: 99)
m
== #(
    a: 1
    b: 2
    "c" 3
    d: 99
)
m/b: none
put m "c" none
extend m [d #[none]]
m
== #(
    a: 1
)
----

[NOTE]
====
Ve výše uvedeném příkladu je použita *construction syntax*, aby bylo možné zadat hodnotu `none!` a nikoliv `word!` (což je jediný způsob vytvoření potřebného bloku specifikací).
====

Je rovněž možné smazat všechny klíče najednou funkcí `clear`:
----
clear #(a 1 b 2 c 3)
== #()
----

 <<anchor-1,toc>>

== Reflexe

Pro práci s mapou (slovníkem) se s výhodou použijí další pomocné funkce:

* `find` ověří přítomnost klíče v mapě a vrátí `true`, byl-li nalezen, v opačném případě vrátí `none`.
----
 find #(a 123 b 456) 'b
 == true
----
* `length?` vrací počet dvojic `key/value` v mapě.
----
 length? #(a 123 b 456)
 == 2
----
* `keys-of` vrací seznam klíčů v mapě formou bloku (set-words are converted to words).
----
 keys-of #(a: 123 b: 456)
 == [a b]
----
* `values-of` vrací seznam hodnot v mapě.
----
 values-of #(a: 123 b: 456)
 == [123 456]
----
* `body-of` vrací všechny dvojice key/value v mapě.
----
 body-of #(a: 123 b: 456)
 == [a: 123 b: 456]
----

<<anchor-1,toc>>