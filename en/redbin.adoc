= Redbin format
:toc:
:toclevels: 3
:numbered:

NOTE: Specification version 2.

Redbin is a binary format that accurately represents Red values stored in memory while enabling fast loading (avoiding the parsing and validation stage of the text representation format). Redbin format is largely inspired by http://www.rebol.com/article/0044.html[REBin]; it can encode binding information for `any-word!` values, references to shared buffers for `series!` values, and can handle arbitrary cycles for `any-block!` values.

The user interface for Redbin format access is provided via codec sub-system. See <<Redbin codec>> section for more details.

== Lexical conventions

NOTE: TBD.

A number of lexical conventions are used throughout this document to describe the Redbin encoding format:

* ()
* =
* []
* ...
* |
* x * y
* Path notation.
* Signed/unsigned sizes and such. Decimal numbers.

== Encoding format

The _default_ encoding format is optimized for decoding speed, while the _compact_ format requires a smaller storage space (at the expense of much slower decoding).

NOTE: Specification of the compact encoding format is not yet defined.

The general layout of Redbin data is described below. Each definition links to a respective section in this document.

<<Header, Redbin header>>:: Holds information about the rest of the Redbin data.
<<Symbol table, Symbol table>>:: Optional; if present, contains interned strings used by records of symbolic datatypes.
<<Records definitions, Payload>>:: Stores Redbin records that encode Red values.

Data in these sections is stored in a little-endian format.

== Header

Redbin data starts with a header having the following format:

----
magic="REDBIN" (6), version=1|2 (1), flags (1), length (4), size (4)

length : number of root records to load.
size   : size of records payload in bytes.
----

Layout of `flags` field is described in the table below.

.Redbin header flags.
[options="header" cols="1,9"]
|===
| Bits | Description 

| 7-3
| Reserved for future use.

| 2
| If set, indicates that Redbin data contains a <<Symbol table, symbol table>>.

| 1
| If set, indicates that data immidiately following `flags` field is compressed. Compression algorithm is implementation-dependent.

| 0
| If set, indicates that records section is encoded using the compact format.

|===

Header is the only mandatory section in Redbin format encoding; both <<Symbol table, symbol table>> and <<Records definitions, payload>> can be ommitted, provided that relevant flags and fields a properly specified.

== Symbol table

The symbol table immediately follows the header data. It is optional and should only be used if `any-word!` values are present in the <<Records definitions, Redbin payload>>. The symbol table has two sections:

Offsets table:: A list of offsets to string representation of each symbol inside the strings buffer;

Strings buffer:: Immidiately follows offsets table; contains UTF-8 encoded, NUL-terminated strings concatenated to each other, with an optional 64-bit boundary padding at the end of each string.

The position of an offset in the table is its _index_ (zero-based), which is used as a reference by symbols in `context!` and  `any-word!` records. The offsets in the table are offsets in bytes from the beginning of the strings buffers section to the referred string.

Table of offsets encoding is described below:

----
Default: length (4), size (4), offset (4) * length
Compact: TBD
----

`length` field contains the number of entries in the table. `size` field indicates the size of the strings buffer in bytes (including optional padding).

During the runtime booting process, these symbols are merged within Red's own symbol table and the offsets are replaced by the symbol ID values from that table. <<Redbin codec, Runtime codec>> omits this merging stage and instantiates symbols in-place for each relevant decoded record.

After the symbol table, Red values are stored as a sequence of records, with no special delimiters or end markers. The loaded values from the root level are stored in a `block!` series.

== Records definitions

Each record in Redbin payload starts with a 32-bit `header` field defined as:

.Layout of Redbin record header.
[options="header" cols="1,9,9"]
|===
| Bits | Description | Relevant datatypes

| 31
| `new-line` flag; if set, indicates the presence of new-line flag in value slot.
| All.

| 30
| `no-values` flag; if set, indicates that `context!` record does not contain value records.
| `context!`

| 29
| `stack?` flag; if set, indicates that values of a decoded `context!` are allocated on data stack.
| `context!`

| 28
| `self?` flag; if set, indicates that decoded `context!` is capable of self-referencing via `self` word.
| `context!`

| 27-26
| `kind` field; encodes `context!` type.
| `context!`

| 25
| `set?` flag; if set, indicates that `any-word!` records is followed by value record to which decoded `any-word!` needs to be set. _TBD In current implementation this is disabled, and flag instead indicates that word is bound to a global context._
| `any-word!`

| 24
| `owner?` flag; if set, indicates that decoded `object!` owns one or more values.
| `object!`

| 23
| `native?` flag; if set, indicates that decoded `op!` value is derived from `native!`, else from `action!`.
| `op!`

| 22
| `body?` flag; if set, indicates that `op!` values is derived from either `function!` or `routine!` and has a body block.
| `op!`

| 21
| `complement?` flag; if set, indicates that decoded `bitset!` value is complemented.
| `bitset!`

| 20
| `sign` flag; if set, indicates that decoded `money!` value has a negative sign.
| `money!`

| 19
| `reference?` flag; if set, indicates that Redbin record contains a reference __TBD link to section__.
| __TBD list datatypes__ `series!`, `any-function!`..?

| 18-16
| Reserved for future use.
| --

| 15-8
| `unit` field; encodes element size (i.e. unit) in a series buffer.
| `series!`

| 7-0
| `type` field; encodes value type.
| All.

|===

Here follows individual descriptions of each type of record.

=== Special

Some types of Redbin records do not correspond to any Red value datatype and are described in this section.

==== Padding

----
Default: header (4)
Compact: N/A

header/type=0
----

This empty record is used to properly align 64-bit values.

==== Reference

----
Default: header (4), length (4), offset (4) * length
Compact: TBD

header/type=255
----

Reference records are used to encode various relations between Red values, such as `any-word!` bindings and shared `series!` buffers.

`length` field specifies the number of `offset` fields contained inside a reference record; each `offset` field specifies a zero-based offset to an already loaded Red value thru its parent, starting from the root block. A list of such offsets effectively forms a path to a referenced value.

Red value that is used as a parent to calculate offset into is called a _waypoint_; Red value to which the path is formed by a reference is called an _apex_. Reference records are usually used by other value records in order to obtain datatype-specific parts that they share with the apex. Red value record that contains a reference is called a _referral_. In all record definitions that follow, referral format is used to describe such form of encoding, which is used only when `reference?` header flag of a respective value record is set.

Redbin records that can act as referrals are: `series!`, `map!`, `bitset!`, `any-word!`, `refinement!`, `object!`, `native!`, `action!`, `function!`.

Only a selected number of datatypes can be a waypoint or an apex, and rules of offset calculation and referencing for each of them are described in the table below.

.Datatypes thru which reference paths can be formed.
[options="header" cols="1,2,2"]
|===
| Datatypes | Waypoint | Apex

| `any-block!`, `map!`
| An offset from the series' head. `map!` is treated as a linear block.
| Buffer is reused.

| `object!`
| An offset from the head of the values block.
| Binding information is reused.

| `any-word!`, `refinement!`
| An offset into a context to which value is bound, which is represented as either `object!` or `function!` value.
| Binding information is reused.

| `action!`, `native!`
| Offset from the head of the spec block.
| Spec buffer is reused.

| `function!`
| Offset of value `0` selects a spec block, offset of value `1` selects a body block. Other offset values are forbidden.
| Binding information is reused.

| `op!`
| Offset of value `0` selects a spec block. Other offset values are forbidden.
| Binding information of `function!` value from which `op!` is derived is reused.

|===

Referral can reference its own parent, in such case a cycle is formed.

=== Datatypes

This section describes the encoding of Redbin records that correspond to Red value datatypes.

==== `datatype!` anchor:datatype[] 

----
Default: header (4), value (4)
Compact: TBD

header/type=1
----

`value` field contains datatype ID represented as a 32-bit integer.

==== `unset!` anchor:unset[] 

----
Default: header (4)
Compact: TBD

header/type=2
----

`unset!` is a singleton value and can be encoded as a `header` field with datatype ID.

==== `none!` anchor:none[] 

----
Default: header (4)
Compact: TBD

header/type=3
----

`none!` is a singleton value and can be encoded as a `header` field with datatype ID.

==== `logic!` anchor:logic[] 

----
Default: header (4), value=0|1 (4)
Compact: TBD

header/type=4
----

`value` content of `0` encodes a `false` value. Non-zero `value` content encodes a `true` value.

==== `block!` anchor:block[] 

----
Default:  header (4), head (4), length (4), ... * length
Referral: header (4), head (4), [reference]
Compact:  TBD

header/type=5
header/reference?=0|1
----

The `head` field indicates a zero-based offset of the index position from block's head. The `length` field contains the number of values to be stored in the block. The block values' records then follow the `length` field.

==== `paren!` anchor:paren[] 

----
Default:  header (4), head (4), length (4), ... * length
Referral: header (4), head (4), [reference]
Compact:  TBD

header/type=6
header/reference?=0|1
----

Same encoding rules as <<block, `block!`>>.

==== `string!` anchor:string[] 

----
Default:  header (4), head (4), length (4), data (header/unit * length), [padding] (1-3)
Referral: header (4), head (4), [reference]
Compact:  TBD

header/type=7
header/unit=1|2|4
header/reference?=0|1
----

The `head` field has same meaning as for other series values. The `unit` field indicates the encoding format of the string, only values of 1, 2 and 4 are valid. The `length` field contains the number of codepoints to be stored in the string, up to 16777215 codepoints (2^24^ - 1) are supported. The string is encoded in either UCS-1, UCS-2 or UCS-4 format, depending on the maximum width of contained codepoints. No NUL-terminating character is present in `data`, nor accounted for in the `length` field. An optional tail padding of 1 to 3 NUL bytes can be present to align the end of the `string!` record with the 32-bit boundary.

==== `file!` anchor:file[] 

----
Default:  header (4), head (4), length (4), data (header/unit * length), [padding] (1-3)
Referral: header (4), head (4), [reference]
Compact:  TBD

header/type=8
header/unit=1|2|4
header/reference?=0|1
----

Same encoding rules as <<string, `string!`>>.

==== `url!` anchor:url[] 

----
Default:  header (4), head (4), length (4), data (header/unit * length), [padding] (1-3)
Referral: header (4), head (4), [reference]
Compact:  TBD

header/type=9
header/unit=1|2|4
header/reference?=0|1
----

Same encoding rules as <<string, `string!`>>.

==== `char!` anchor:char[] 

----
Default: header (4), value (4)
Compact: TBD

header/type=10
----

`value` field contains a UCS-4 codepoint stored as a 32-bit integer.

==== `integer!` anchor:integer[] 

----
Default: header (4), value (4)
Compact: TBD

header/type=11
----

`value` field contains a signed 32-bit integer that encoded Red value represents.

= TBD

=== Float! anchor:float[] 

----
Default: [padding=0 (4),] header (4), value (8)
Compact: TBD

header/type=12

----
The optional padding field is added to properly align the `value` field offset to a 64-bit boundary.

=== Context! anchor:context[] 

----
Default: header (4), length (4), symbol1 (4), symbol2 (4),..., value1 [any-type!], value2 [any-type!], ...
Compact: TBD

header/type=14
header/no-values=0|1
header/stack?=0|1
header/self?=0|1
----

Contexts are Red values used internally by some datatypes like `function!`, `object!` and derivative types. A context contains two consecutive tables, the first one is the list of word entries in the context represented as symbol references, the second is the associated values for each of the symbols in the first table. `length` field indicates the number of entries in the context. Context records can only exist at root level, they cannot be nested. If `no-values` flag is set, it means that there are no values following the symbols (empty context). If `stack?` flag is set, then the values are allocated on the stack instead of the heap memory. The `self?` flag is used to indicate that the context is able to handle a self-referencing word (`self` in objects).

=== Word! anchor:word[] 

----
Default: header (4), symbol (4), context (4), index (4)
Compact: TBD

header/type=15
header/set?=0|1
----

The `context` field is an offset from the beginning of the records section in the Redbin file referring to a `context!` value. The context needs to be located before the word record in the Redbin records list. If `context` equals `-1`, it refers to global context.

If the `set?` field is defined, this record is followed by an `any-value!` record, and the word will need to be set to that value (in the right context) by the decoder. This forms a name/value couple allowing to encode words' values in an adhoc way, when providing a sequence of values for a given context is too expensive (mostly for name/value couples in global context).

=== Set-word! anchor:set-word[] 

----
Default: header (4), symbol (4), context (4), index (4)
Compact: TBD

header/type=16
----

Same as `word!`.

=== Lit-word! anchor:lit-word[] 

----
Default: header (4), symbol (4), context (4), index (4)
Compact: TBD

header/type=17
----
Same as `word!`.

=== Get-word! anchor:get-word[] 

----
Default: header (4), symbol (4), context (4), index (4)
Compact: TBD

header/type=18
----
Same as `word!`.

=== Refinement! anchor:refinement[] 

----
Default: header (4), symbol (4), context (4), index (4)
Compact: TBD

header/type=19
----

Same as `word!`.

=== Issue! anchor:issue[] 

----
Default: header (4), symbol (4)
Compact: TBD

header/type=20
----

=== Native! anchor:native[] 

----
Default: header (4), ID (4), spec [block!]
Compact: TBD

header/type=21
----

`ID` is an offset into the internal `natives/table` jump table.


=== Action! anchor:action[] 

----
Default: header (4), ID (4), spec [block!]
Compact: TBD

header/type=22
----

`ID` is an offset into the internal `actions/table` jump table.

=== Op! anchor:op[] 

----
Default: header (4), symbol (4), 
Compact: TBD

header/type=23
----

`symbol` represents the action, native or function name (only from global context) used as the source for that `op!` value. 


=== Function! anchor:function[] 

----
Default: header (4), context [context!], spec [block!], body [block!], args [block!], obj-ctx [context!]
Compact: TBD

header/type=24
----

=== Path! anchor:path[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=25
----

Same encoding rules as `block!`.

=== Lit-path! anchor:lit-path[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=26
----

Same encoding rules as `block!`.

=== Set-path! anchor:set-path[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=27
----

Same encoding rules as `block!`.

=== Get-path! anchor:get-path[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=28
----

Same encoding rules as `block!`.

=== Bitset! anchor:bitset[] 

----
Default: header (4), length (4), bits (length)
Compact: TBD

header/type=30
----

The `length` fields indicates the number of bits stored, rounded to the upper multiple of 8. The bits are memory dumps of the `bitset!` series buffer. Byte order is preserved. `bits` field needs to be padded with enough NUL bytes to keep the next record 32-bit aligned.

=== Point! anchor:point[] 

----
Default: header (4), x (4), y (4), z (4)
Compact: TBD

header/type=31
----

=== Object! anchor:object[] 

----
Default: header (4), context [reference!], class-id (4), on-set-idx (4), on-set-arity (4)
Compact: TBD

header/type=32
----

The `on-set-idx` field indicates the offset of the `on-change*` in the context values table. The `on-set-arity` stores the arity of that function.

=== Typeset! anchor:typeset[] 

----
Default: header (4), array1 (4), array2 (4), array3 (4)
Compact: TBD

header/type=33
----

=== Error! anchor:error[] 

----
Default: header (4), context [reference!]
Compact: TBD

header/type=34
----

=== Vector! anchor:vector[] 

----
Default: header (4), head (4), length (4), values (unit*length)
Compact: TBD

header/type=35
----

`unit` indicates the size of the vector element type size: 1, 2, 4 or 8 bytes. The `values` field holds the list of values. `values` needs to be padded with NUL bytes to align the next record to a 32-bit boundary (if `unit` is equal to 1 or 2).

=== Pair! anchor:pair[] 

----
Default: header (4), x (4), y (4)
Compact: TBD

header/type=37
----

=== Percent! anchor:percent[] 

----
Default: [padding=0 (4),] header (4), value (8)
Compact: TBD

header/type=38
----

Percent value is stored as a 64-bit float. The optional padding field is added to properly align the `value` field offset to a 64-bit boundary.

=== Tuple! anchor:tuple[] 

----
Default: header (4), array1 (4), array2 (4), array3 (4)
Compact: TBD

header/type=39
----

=== Map! anchor:map[] 

----
Default: header (4), length (4), ...
Compact: TBD

header/type=40
----

The `length` field contains the number of elements (keys + values) to be stored in the map. The map elements simply follow the length definition, no separator or end delimiter is required.

=== Binary! anchor:binary[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=41
----

Same encoding rules as `block!`.

=== Time! anchor:time[] 

----
Default: [padding=0 (4),] header (4), value (8)
Compact: TBD

header/type=43
----

Time value is stored as a 64-bit float. The optional padding field is added to properly align the `value` field offset to a 64-bit boundary.

=== Tag! anchor:tag[] 

----
Default: header (4), head (4), length (4), data (unit*length)
Compact: TBD

header/type=44
header/unit=1|2|4
----

Same encoding rules as `string!`.

=== Email! anchor:email[] 

----
Default: header (4), head (4), length (4), data (unit*length)
Compact: TBD

header/type=45
header/unit=1|2|4
----

Same encoding rules as `string!`.

=== Date! anchor:date[] 

----
Default: header (4), date (4), time (8)
Compact: TBD

header/type=47
----

Date is packed into a 32-bit integer (same as in `red-date!`). Time value is stored as a 64-bit float.

=== Money! anchor:money[] 

----
Default: header (4), currency (1), amount (11)
Compact: TBD

header/type=49
header/sign=0|1
----

`amount` is a sequence of nibbles representing the money integral and decimal part (22 digits) in network byte order. If `sign` is set, the amount is interpreted as negative. `currency` is an integer value (0 for generic money, < 255 for existing currency code).

=== Ref! anchor:ref[]

----
Default: header (4), head (4), length (4), data (unit*length)
Compact: TBD

header/type=50
header/unit=1|2|4
----

Same encoding rules as `string!`.

== Redbin codec

_TBD_