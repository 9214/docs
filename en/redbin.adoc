= Redbin format
:toc:
:numbered:

_Specification version 2_

Redbin is a binary format that accurately represents Red values stored in memory, while enabling fast loading (avoiding the parsing and validation stage of the text representation format). Redbin format is largely inspired by http://www.rebol.com/article/0044.html[REBin]. Redbin can encode binding information for words and can handle cycles in `any-block!` values.

The user interface for Redbin format access is provided via codec sub-system. See <<Redbin codec>> section for details _TBD_.

== Encoding format

The _default_ encoding format is optimized for decoding speed, while the _compact_ format requires a smaller storage space (at the expense of much slower decoding).

NOTE: Specification of the compact encoding format is not yet defined.

The general layout of Redbin data is described below. Each definition links to a respective section in this document.

<<Header, Redbin header>>:: Holds information about the rest of the Redbin data.
<<Symbol table, Symbol table>>:: Optional; if present, contains interned strings used by records of symbolic datatypes.
<<Records definitions, Payload>>:: Stores Redbin records that encode Red values.

Data in these sections is stored in a little-endian format.

== Header

Redbin data starts with a header having the following format:

----
magic="REDBIN" (6), version=1|2 (1), flags (1), length (4), size (4)

length : number of root records to load.
size   : size of records payload in bytes.
----

Layout of `flags` field is described in the table below.

.Redbin header flags.
[options="header" cols="1,9"]
|===
| Bits | Description 

| 7-3
| Reserved for future use.

| 2
| If set, indicates that Redbin data contains a <<Symbol table, symbol table>>.

| 1
| If set, indicates that data immidiately following `flags` field is compressed. Compression algorithm is implementation-dependent.

| 0
| If set, indicates that records section is encoded using the compact format.

|===

Header is the only mandatory section in Redbin format encoding; both <<Symbol table, symbol table>> and <<Records definitions, payload>> can be ommitted, provided that relevant flags and fields a properly specified.

== Symbol table

The symbol table immediately follows the header data. It is optional and should only be used if `any-word!` values are present in the <<Records definitions, Redbin payload>>. The symbol table has two sections:

Offsets table:: A list of offsets to string representation of each symbol inside the strings buffer;

Strings buffer:: Immidiately follows offsets table; contains UTF-8 encoded, NUL-terminated strings concatenated to each other, with an optional 64-bit boundary padding at the end of each string.

The position of an offset in the table is its _index_ (zero-based), which is used as a reference by symbols in `context!` and  `any-word!` records. The offsets in the table are offsets in bytes from the beginning of the strings buffers section to the referred string.

Table of offsets encoding is described below:

----
Default: length (4), size (4), offset (4) * length
Compact: TBD
----

`length` field contains the number of entries in the table. `size` field indicates the size of the strings buffer in bytes (including optional padding).

During the runtime booting process, these symbols are merged within Red's own symbol table and the offsets are replaced by the symbol ID values from that table. <<Redbin codec, Runtime codec>> omits this merging stage and instantiates symbols in-place for each relevant decoded record.

After the symbol table, Red values are stored as a sequence of records, with no special delimiters or end markers. The loaded values from the root level are stored in a `block!` series.

== Records definitions

Each record in Redbin payload starts with a 32-bit `header` field defined as:

.Layout of Redbin record header.
[options="header" cols="1,9,9"]
|===
| Bits | Description | Relevant datatypes

| 31
| `new-line` flag; if set, indicates the presence of new-line flag in value slot.
| All.

| 30
| `no-values` flag; if set, indicates that `context!` record does not contain value records.
| `context!`

| 29
| `stack?` flag; if set, indicates that values of a decoded `context!` are allocated on data stack.
| `context!`

| 28
| `self?` flag; if set, indicates that decoded `context!` is capable of self-referencing via `self` word.
| `context!`

| 27-26
| `kind` field; encodes `context!` type.
| `context!`

| 25
| `set?` flag; if set, indicates that `any-word!` records is followed by value record to which decoded `any-word!` needs to be set. _TBD In current implementation this is disabled, and flag instead indicates that word is bound to a global context._
| `any-word!`

| 24
| `owner?` flag; if set, indicates that decoded `object!` owns one or more values.
| `object!`

| 23
| `native?` flag; if set, indicates that decoded `op!` value is derived from `native!`, else from `action!`.
| `op!`

| 22
| `body?` flag; if set, indicates that `op!` values is derived from either `function!` or `routine!` and has a body block.
| `op!`

| 21
| `complement?` flag; if set, indicates that decoded `bitset!` value is complemented.
| `bitset!`

| 20
| `sign` flag; if set, indicates that decoded `money!` value has a negative sign.
| `money!`

| 19
| `reference?` flag; if set, indicates that Redbin record contains a reference __TBD link to section__.
| __TBD list datatypes__ `series!`, `any-function!`..?

| 18-16
| Reserved for future use.
| --

| 15-8
| `unit` field; encodes element size (i.e. unit) in a series buffer.
| `series!`

| 7-0
| `type` field; encodes value type.
| All.

|===

Here follows the description of each individual record:

=== Padding anchor:padding[] 

----
Default: header (4)
Compact: n/a

header/type=0
----

This empty type slot is used to properly align 64-bit values.

=== Datatype! anchor:datatype[] 

----
Default: header (4), value (4)
Compact: TBD

header/type=1
----

=== Unset! anchor:unset[] 

----
Default: header (4)
Compact: TBD

header/type=2
----

=== None! anchor:none[] 

----
Default: header (4)
Compact: TBD

header/type=3
----

=== Logic! anchor:logic[] 

----
Default: header (4), value=0|1 (4)
Compact: TBD

header/type=4
----

=== Block! anchor:block[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=5
----

The `head` field indicates the offset of the block reference, using a zero-based integer. The `length` field contains the number of values to be stored in the block. The block values simply follow the block definition, no separator or end delimiter is required.

=== Paren! anchor:paren[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=6
----

Same encoding rules as `block!`.

=== String! anchor:string[] 

----
Default: header (4), head (4), length (4), data (unit*length) [, padding (1-3)]
Compact: TBD

header/type=7
header/unit=1|2|4
----

`head` field has same meaning as for blocks. The `unit` sub-field indicates the encoding format of the string, only values of 1, 2 and 4 are valid. The `length` field contains the number of codepoints to be stored in the string, up to 16777215 codepoints (2^24 - 1) are supported. The string is encoded in UCS-1, UCS-2 or UCS-4 format. No NUL character is present, nor accounted for in the `length` field. An optional tail padding of 1 to 3 NUL bytes can be present to align the end of the `string!` record with a 32-bit boundary.

=== File! anchor:file[] 

----
Default: header (4), head (4), length (4), data (unit*length)
Compact: TBD

header/type=8
header/unit=1|2|4
----

Same encoding rules as `string!`.

=== Url! anchor:url[] 

----
Default: header (4), head (4), length (4), data (unit*length)
Compact: TBD

header/type=9
----

Same encoding rules as `string!`.

=== Char! anchor:char[] 

----
Default: header (4), value (4)
Compact: TBD

header/type=10
----

=== Integer! anchor:integer[] 

----
Default: header (4), value (4)
Compact: TBD

header/type=11
----

=== Float! anchor:float[] 

----
Default: [padding=0 (4),] header (4), value (8)
Compact: TBD

header/type=12

----
The optional padding field is added to properly align the `value` field offset to a 64-bit boundary.

=== Context! anchor:context[] 

----
Default: header (4), length (4), symbol1 (4), symbol2 (4),..., value1 [any-type!], value2 [any-type!], ...
Compact: TBD

header/type=14
header/no-values=0|1
header/stack?=0|1
header/self?=0|1
----

Contexts are Red values used internally by some datatypes like `function!`, `object!` and derivative types. A context contains two consecutive tables, the first one is the list of word entries in the context represented as symbol references, the second is the associated values for each of the symbols in the first table. `length` field indicates the number of entries in the context. Context records can only exist at root level, they cannot be nested. If `no-values` flag is set, it means that there are no values following the symbols (empty context). If `stack?` flag is set, then the values are allocated on the stack instead of the heap memory. The `self?` flag is used to indicate that the context is able to handle a self-referencing word (`self` in objects).

=== Word! anchor:word[] 

----
Default: header (4), symbol (4), context (4), index (4)
Compact: TBD

header/type=15
header/set?=0|1
----

The `context` field is an offset from the beginning of the records section in the Redbin file referring to a `context!` value. The context needs to be located before the word record in the Redbin records list. If `context` equals `-1`, it refers to global context.

If the `set?` field is defined, this record is followed by an `any-value!` record, and the word will need to be set to that value (in the right context) by the decoder. This forms a name/value couple allowing to encode words' values in an adhoc way, when providing a sequence of values for a given context is too expensive (mostly for name/value couples in global context).

=== Set-word! anchor:set-word[] 

----
Default: header (4), symbol (4), context (4), index (4)
Compact: TBD

header/type=16
----

Same as `word!`.

=== Lit-word! anchor:lit-word[] 

----
Default: header (4), symbol (4), context (4), index (4)
Compact: TBD

header/type=17
----
Same as `word!`.

=== Get-word! anchor:get-word[] 

----
Default: header (4), symbol (4), context (4), index (4)
Compact: TBD

header/type=18
----
Same as `word!`.

=== Refinement! anchor:refinement[] 

----
Default: header (4), symbol (4), context (4), index (4)
Compact: TBD

header/type=19
----

Same as `word!`.

=== Issue! anchor:issue[] 

----
Default: header (4), symbol (4)
Compact: TBD

header/type=20
----

=== Native! anchor:native[] 

----
Default: header (4), ID (4), spec [block!]
Compact: TBD

header/type=21
----

`ID` is an offset into the internal `natives/table` jump table.


=== Action! anchor:action[] 

----
Default: header (4), ID (4), spec [block!]
Compact: TBD

header/type=22
----

`ID` is an offset into the internal `actions/table` jump table.

=== Op! anchor:op[] 

----
Default: header (4), symbol (4), 
Compact: TBD

header/type=23
----

`symbol` represents the action, native or function name (only from global context) used as the source for that `op!` value. 


=== Function! anchor:function[] 

----
Default: header (4), context [context!], spec [block!], body [block!], args [block!], obj-ctx [context!]
Compact: TBD

header/type=24
----

=== Path! anchor:path[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=25
----

Same encoding rules as `block!`.

=== Lit-path! anchor:lit-path[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=26
----

Same encoding rules as `block!`.

=== Set-path! anchor:set-path[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=27
----

Same encoding rules as `block!`.

=== Get-path! anchor:get-path[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=28
----

Same encoding rules as `block!`.

=== Bitset! anchor:bitset[] 

----
Default: header (4), length (4), bits (length)
Compact: TBD

header/type=30
----

The `length` fields indicates the number of bits stored, rounded to the upper multiple of 8. The bits are memory dumps of the `bitset!` series buffer. Byte order is preserved. `bits` field needs to be padded with enough NUL bytes to keep the next record 32-bit aligned.

=== Point! anchor:point[] 

----
Default: header (4), x (4), y (4), z (4)
Compact: TBD

header/type=31
----

=== Object! anchor:object[] 

----
Default: header (4), context [reference!], class-id (4), on-set-idx (4), on-set-arity (4)
Compact: TBD

header/type=32
----

The `on-set-idx` field indicates the offset of the `on-change*` in the context values table. The `on-set-arity` stores the arity of that function.

=== Typeset! anchor:typeset[] 

----
Default: header (4), array1 (4), array2 (4), array3 (4)
Compact: TBD

header/type=33
----

=== Error! anchor:error[] 

----
Default: header (4), context [reference!]
Compact: TBD

header/type=34
----

=== Vector! anchor:vector[] 

----
Default: header (4), head (4), length (4), values (unit*length)
Compact: TBD

header/type=35
----

`unit` indicates the size of the vector element type size: 1, 2, 4 or 8 bytes. The `values` field holds the list of values. `values` needs to be padded with NUL bytes to align the next record to a 32-bit boundary (if `unit` is equal to 1 or 2).

=== Pair! anchor:pair[] 

----
Default: header (4), x (4), y (4)
Compact: TBD

header/type=37
----

=== Percent! anchor:percent[] 

----
Default: [padding=0 (4),] header (4), value (8)
Compact: TBD

header/type=38
----

Percent value is stored as a 64-bit float. The optional padding field is added to properly align the `value` field offset to a 64-bit boundary.

=== Tuple! anchor:tuple[] 

----
Default: header (4), array1 (4), array2 (4), array3 (4)
Compact: TBD

header/type=39
----

=== Map! anchor:map[] 

----
Default: header (4), length (4), ...
Compact: TBD

header/type=40
----

The `length` field contains the number of elements (keys + values) to be stored in the map. The map elements simply follow the length definition, no separator or end delimiter is required.

=== Binary! anchor:binary[] 

----
Default: header (4), head (4), length (4), ...
Compact: TBD

header/type=41
----

Same encoding rules as `block!`.

=== Time! anchor:time[] 

----
Default: [padding=0 (4),] header (4), value (8)
Compact: TBD

header/type=43
----

Time value is stored as a 64-bit float. The optional padding field is added to properly align the `value` field offset to a 64-bit boundary.

=== Tag! anchor:tag[] 

----
Default: header (4), head (4), length (4), data (unit*length)
Compact: TBD

header/type=44
header/unit=1|2|4
----

Same encoding rules as `string!`.

=== Email! anchor:email[] 

----
Default: header (4), head (4), length (4), data (unit*length)
Compact: TBD

header/type=45
header/unit=1|2|4
----

Same encoding rules as `string!`.

=== Date! anchor:date[] 

----
Default: header (4), date (4), time (8)
Compact: TBD

header/type=47
----

Date is packed into a 32-bit integer (same as in `red-date!`). Time value is stored as a 64-bit float.

=== Money! anchor:money[] 

----
Default: header (4), currency (1), amount (11)
Compact: TBD

header/type=49
header/sign=1|0 (bit 14)
----

`amount` is a sequence of nibbles representing the money integral and decimal part (22 digits) in network byte order. If `sign` is set, the amount is interpreted as negative. `currency` is an integer value (0 for generic money, < 255 for existing currency code).

=== Ref! anchor:ref[]

----
Default: header (4), head (4), length (4), data (unit*length)
Compact: TBD

header/type=50
header/unit=1|2|4
----

Same encoding rules as `string!`.

=== Reference! anchor:reference[] 

----
Default: header (4), count (4), index1 (4), index2 (4), ...
Compact: TBD

header/type=255
----

This special record type stores a reference to an already loaded value of type `any-block!` or `object!`. This makes it possible to store cycles in Redbin. The reference is created from a path into the loaded values (assuming that the root values are stored in a block). Each `index` field points to the series or object value to go into, until the last one is reached, pointing to the value to refer to. The `count` field indicates the number of indexes to go through. If one of the indexes has to be applied to an object, it refers to the corresponding object's field (0 => 1st field, 1 => 2nd field,...). All indexes are zero-based.

== Redbin codec

_TBD_